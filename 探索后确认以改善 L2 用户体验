在最近的一篇文章中，我们介绍了一种快速确定性机制。在本文中，我们将深入探讨该机制并解决以下问题：

它与预先确认有何不同

它如何补充其他最终性机制，如零知识证明（ZKP）或欺诈证明（FP）

改进和优化

我们想要解决的问题是什么？
第 2 层 (L2) 和 rollups 必须将交易数据发布到数据可用性 (DA)层或以太坊主网 (第 1 层，L1)。有效性 (ZKP) 和乐观 (FP) rollups 可以在大约 30 分钟 (ZKP) 或大约 1 周 (FP) 内完成(确认) 交易。在交易完成之前，无法保证其有效性和结果 (成功或失败)。这可能是某些类型的 DeFi 应用程序的限制因素。

所以问题是：

我们能否设计一种机制，快速为 L2 上的交易结果提供一些保证？

答案是肯定的——通过事后确认。图 1 总结了这个想法。


图 1：安全级别和最终确定时间。最终确定时间不包括L1（以太坊）平均最终确定时间，该时间约为 13 分钟。对于 ZK 证明，这是生成证明的时间。而对于欺诈证明，大约需要 1 周的时间，因此 13 分钟没有任何区别。

ZK 证明提供最高级别的安全性并继承了以太坊的安全性（有关继承的确切含义，我们请读者参阅最近的这篇文章）；最终性约为 30 分钟。欺诈性证明提供的安全级别范围从无（如果挑战期结束并且没有验证者检查结果）到以太坊的安全性；对于 FP，最终性约为 7 天。

L2 可以通过事后确认来提供中间级别的安全性，即 L2 权益安全性（我们将在后续内容中解释它们是什么）。

后确认速度很快（约 1 秒），因为它们是在创建新块时执行一组交易后立即传送的。

总体而言，用户现在可以快速获得有关其交易结果的一些保证，并可以决定这是否足以假设确认或等待 L1 最终性（使用 ZKP 或 FP）以获得以太坊的安全级别。

一些中心化交易所会根据交易所在区块后面的区块数量来提供交易的早期确认。然而，除非由最长链机制提供最终确认，否则这种早期确认并不能得到保证。

预先确认与后确认
我们提出的机制是为 L2 交易提供后确认。如图 2 所示。此机制不同于基于排序的预确认。它不仅保证交易将被纳入（或执行），还保证新区块是正确的。它不能替代复杂的执行票证机制，因为它不提供影响区块创建的方法，而是报告区块中交易的正确执行情况。


图 2：交易的确认阶段。预确认是（由排序器做出的）承诺，即交易将包含在下一个区块中。相比之下，后确认旨在提供一些由 L2 质押支持的保证，即新状态（在执行器处理完交易之后）是正确的。

确认后如何工作？
验证者网络（图 3）负责验证新区块。每个验证者必须在 L1StakingK合约中质押一些资产。我们假设每个验证者质押的金额相同。

我们假设最多 1/3 的验证者可以不诚实（拜占庭）。诚实的验证者只有在区块正确时才会（积极地）证明区块正确。

我们请读者参阅这篇文章来了解正确性的精确定义。


图 3：验证者网络验证新区块。他们将已签名的证明提交给 L1 上的质押合约，以确认/拒绝新区块。

一个简单的设计（我们将在后续文章中对其进行改进）是每个验证者将其证明✅或❌发送给合约 StakingK。一旦合约收到 2/3（绝大多数）对新区块的正面✅证明，新区块就会被确认。

我们对后续确认能有什么信心？
验证者将他们的证明发送给StakingK ，他们不能更改或撤回它们，并且必须遵守它们。如果稍后（在使用 ZK 证明或欺诈证明验证区块时）发现它们是错误的（有意或无意），则会被削减。结果：

当他们证明时，他们有动力诚实地这样做，否则他们可能会失去他们的利益。

他们无法撤销投票，当 2/3（绝大多数）的人投出赞成票时，我们可以高度确信新区块是正确的。即使StakingK检查绝大多数的交易（）的执行尚未在 L1 上完成，这一点仍然成立。

如果总权益很大StakingK，攻击者很难控制超过 1/3 的验证者以防止获得绝对多数，甚至更难控制 2/3 来验证错误的区块。如果有足够多的验证者（和权益）参与网络，L2 权益安全级别（图 1）可以接近以太坊的安全级别。

合约StakingK管理权益（质押、奖励和削减），并假定其正确无误（无错误）。它提供接收签名证明的功能，并根据 2/3 绝对多数阈值验证签名。它在 L1 上执行，其执行继承了以太坊的安全性。

在这种设计中，验证者无需重新计算新区块来验证其正确性。他们只需确保当他们证明正确时，这个新区块是正确的（因此他们可以在不执行任何检查的情况下进行证明）。此外，如果每个验证者都发出 L1 交易来投出他们的证明，那么之前的简单设计可能会非常昂贵。我们将在下一节中解决这两个限制。

汇总证明
为了使认证过程更加高效，我们可以要求验证者运行 L1 轻客户端。他们可以访问 的状态，StakingK并可以自行确定有多少验证者处于活动状态。

活跃验证者是指其质押还未被削减的验证者。我们在此假设，如果验证者质押被削减，削减机制会削减其全部质押。

验证者可以将他们对新区块的投票广播到整个验证者网络。验证者可以记录和汇总已签名的证明。当其中一位验证者确定已达到 2/3 绝对多数时，他们可以将汇总（已签名）的证明发送到合约StakingK。这减少了记录证明所需的 L1 交易数量。

我们还应该注意：

验证者记录正面✅和负面❌证明，并将两种类型的证明发送给StakingK。一旦达到 2/3 的绝对多数，StakingK 合约就可以削减那些提供负面证明的验证者，因为他们是不诚实的（假设最多 1/3 的验证者可以是拜占庭的）。

由于验证者依赖最近的合约状态StakingK（计算 2/3 多数阈值），我们必须防止验证者过快撤回其质押。这是为了确保不诚实的验证者不能错误/不诚实地证明，然后在被削减之前撤回其质押。我们可以将质押锁定一段预定义的时间（几个时期）。

诚实或不诚实的验证者发布聚合签名并不重要。假设签名无法篡改，不诚实的验证者只能保留一些签名或不向 L1 发布任何内容，但无法伪造一组无效的证明。

隐藏承诺
如上所述，验证者可以在不检查新区块的情况下进行证明。例如，如果验证者收集了超过 1/3 的正面证明，他们也可以盲目地进行正面证明（假设最多 1/3 的验证者可以进行拜占庭式验证，则风险很低）。

为了激励验证者进行一些实际验证，我们可以要求他们提供他们已经重新计算新区块的证明（如果尚不存在 ZKP，这是检查区块正确性的唯一方法）。


图 4：新的区块/状态只有在 2/3 的验证者证实后才会公布。验证者可以提交（ZK）证明以及他们的证实。

在这个设置中（图 4），我们必须隐藏新的区块/状态，直到 2/3 多数人证明它。

为此，我们可以发送交易序列 𝑡 1 ,⋯,𝑡 k、源状态 𝑠 0和新块/状态 𝑠 𝑘的哈希 #𝑠 𝑘 ，而暂时不透露新状态 𝑠 𝑘 。验证者可以广播积极证明以及ZKP，表明他们知道状态 𝑠′ 的哈希与 #𝑠 𝑘相同（这比整个交易执行的 ZKP 更容易计算）。由于哈希函数不可逆且无碰撞，如果他们知道这样的状态 𝑠′，则意味着：

𝑠 𝑘与 𝑠′ 相同

他们一定重新计算了（很有可能）新的状态𝑠′（他们不太可能猜到）

这进一步增强了新区块/状态正确性的可信度，因为它强制验证了新区块/状态。同时，它使我们能够弱化信任假设，因为我们可能不需要假设诚实的验证者会重新计算新状态，他们必须证明这一点。

我们仍然可以允许验证者提交没有证明的证明，但与做更多（可验证）工作的人相比，他们可能会获得较少的奖励。
